from livekit.agents import function_tool
import os
import subprocess
import json
import openai
from dotenv import load_dotenv
import re
import ast
import os
import git  # GitPython
from git import Repo
from livekit.agents import function_tool

load_dotenv()

# File to store the last opened project path
PROJECT_MEMORY_FILE = os.path.expanduser(
    "/Users/daniel/Documents/Projects/VISUAL STUDIO CODE/project_memory.json"
)
def save_current_project(project_path: str):
    """Save the last opened project to memory."""
    with open(PROJECT_MEMORY_FILE, "w") as f:
        json.dump({"current_project": project_path}, f)

def get_current_project() -> str:
    """Retrieve the last opened project from memory."""
    if os.path.exists(PROJECT_MEMORY_FILE):
        with open(PROJECT_MEMORY_FILE, "r") as f:
            data = json.load(f)
            return data.get("current_project")
    return None

PYTHON_PATH = os.getenv("PYTHON_PATH", "~/projects")
# Hardcoded root path for all projects
PROJECTS_ROOT = os.path.expanduser(
    PYTHON_PATH
)  # Change this if needed

def get_comment_prefix(file_name: str) -> str:
    """Return correct comment prefix based on file extension."""
    extension = os.path.splitext(file_name)[1].lower()
    return {
        ".py": "#",
        ".js": "//",
        ".ts": "//",
        ".java": "//",
        ".c": "//",
        ".cpp": "//",
        ".cs": "//",
        ".go": "//",
        ".rb": "#",
        ".php": "//",
        ".swift": "//"
    }.get(extension, "#")  # Default to Python-style comments
    
@function_tool
async def manage_python_project(project_name: str, language: str = "python") -> str:
    """
    Create or open a VS Code project automatically.

    Args:
        project_name (str): Name of the project (e.g., "MyApp").
        language (str): Programming language for the project. Default = "python".

    Returns:
        str: Status message.
    """
    try:
        # Ensure the root folder exists
        os.makedirs(PROJECTS_ROOT, exist_ok=True)

        # Full path for this project
        project_path = os.path.join(PROJECTS_ROOT, project_name)

        # Check if project already exists
        project_exists = os.path.exists(project_path)

        if not project_exists:
            os.makedirs(project_path, exist_ok=True)

            # Create a virtual environment for Python projects
            if language.lower() == "python":
                subprocess.run(
                    ["python3", "-m", "venv", os.path.join(project_path, "venv")]
                )

            # Add a default README.md
            readme_path = os.path.join(project_path, "README.md")
            with open(readme_path, "w") as f:
                f.write(f"# {project_name}\n\nGenerated by Jarvis.\n")
                
            

        # âœ… Save project path so Jarvis knows the active project
        save_current_project(project_path)

        # Open VS Code via AppleScript
        applescript = f'''
        tell application "Visual Studio Code"
            open POSIX file "{project_path}"
            activate
        end tell
        '''
        subprocess.run(["osascript", "-e", applescript])

        if project_exists:
            return f"ğŸ“‚ Opened existing project: {project_name}"
        else:
            return f"ğŸ†• Created and opened new {language} project: {project_name}"

    except Exception as e:
        return f"âŒ Failed to manage project: {str(e)}"


@function_tool
async def create_or_open_python(file_name: str) -> str:
    """
    Create or open a file inside the **currently active VS Code project**.

    Args:
        file_name (str): Name of the file (e.g., "main.py" or "src/app.js").

    Returns:
        str: Status message.
    """
    try:
        # âœ… Get the active project from memory
        project_path = get_current_project()
        if not project_path:
            return "âš ï¸ No active project found. Please open a project first using manage_vscode_project."

        # Build full path for the file
        file_path = os.path.join(project_path, file_name)

        # Create necessary directories if they don't exist
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        # Create file if it doesn't exist
        open(file_path, "a").close()

        # Open the file inside VS Code in the SAME window
        subprocess.run(["code", "--reuse-window", file_path])

        return f"âœ… File '{file_name}' opened at {file_path}"

    except Exception as e:
        return f"âŒ Failed to open file: {str(e)}"
    

@function_tool
async def generate_python_code(file_name: str, prompt: str, model: str = "gpt-5-mini") -> str:
    """
    Generate code using GPT-5 and insert it into a file inside the active project.
    Explanations are automatically converted into code comments.
    """
    try:
        # Get the active project path
        project_path = get_current_project()
        if not project_path:
            return "âš ï¸ No active project found. Please open a project first using manage_vscode_project."

        # Build full path for the file
        file_path = os.path.join(project_path, file_name)
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        # Initialize OpenAI client
        openai.api_key = os.getenv("OPENAI_API_KEY")
        if not openai.api_key:
            return "âš ï¸ OpenAI API key not set. Please set OPENAI_API_KEY in your environment variables."

        # Detect comment style based on file extension
        comment_prefix = get_comment_prefix(file_name)

        # Generate code using GPT-5
        response = openai.chat.completions.create(
            model=model,
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You are an expert code generator. "
                        "Always return clean, executable code. "
                        "Any explanations must be provided ONLY as inline comments "
                        f"using '{comment_prefix}' syntax. "
                        "Do not return Markdown formatting, no triple backticks."
                    )
                },
                {"role": "user", "content": prompt}
            ]
        )

        # Extract the code from GPT-5 response
        code = response.choices[0].message.content.strip()

        # Clean up any leftover formatting
        code = re.sub(r"```[a-zA-Z0-9]*", "", code).replace("```", "").strip()

        # Write code to file
        with open(file_path, "w") as f:
            f.write(code)

        # Open file in VS Code
        subprocess.run(["code", "--reuse-window", file_path])

        return f"âœ… Code generated with explanations as comments in '{file_name}'"

    except Exception as e:
        return f"âŒ Failed to generate code: {str(e)}"

@function_tool
async def initialize_git_repo(project_name: str, github_remote_url: str = None) -> str:
    """
    Initialize a Git repository for the given project without making any commits.
    Optionally add a remote URL.

    Args:
        project_name (str): Project name.
        github_remote_url (str, optional): Remote GitHub repo URL.

    Returns:
        str: Status message.
    """
    try:
        project_path = os.path.join(PROJECTS_ROOT, project_name)

        if not os.path.exists(project_path):
            return f"âš ï¸ Project '{project_name}' does not exist."

        # Initialize repo if not already initialized
        if not os.path.exists(os.path.join(project_path, ".git")):
            repo = Repo.init(project_path)
        else:
            repo = Repo(project_path)

        # Add remote if provided
        if github_remote_url:
            if "origin" not in [r.name for r in repo.remotes]:
                repo.create_remote("origin", github_remote_url)
            else:
                repo.remotes.origin.set_url(github_remote_url)

            return f"âœ… Git repo initialized and remote set for '{project_name}'."
        return f"âœ… Git repository initialized for '{project_name}'."

    except Exception as e:
        return f"âŒ Failed to initialize Git repo: {str(e)}"


@function_tool
async def git_stage_file(project_name: str, file_path: str) -> str:
    """Stage a specific file (like 'git add file')."""
    try:
        project_path = os.path.join(PROJECTS_ROOT, project_name)
        repo = Repo(project_path)

        abs_file_path = os.path.join(project_path, file_path)
        if not os.path.exists(abs_file_path):
            return f"âš ï¸ File '{file_path}' does not exist."

        repo.git.add(file_path)
        return f"âœ… Staged file: {file_path}"

    except Exception as e:
        return f"âŒ Failed to stage file: {str(e)}"


@function_tool
async def git_unstage_file(project_name: str, file_path: str) -> str:
    """Unstage a specific file (like 'git reset HEAD file')."""
    try:
        project_path = os.path.join(PROJECTS_ROOT, project_name)
        repo = Repo(project_path)

        repo.git.reset("HEAD", file_path)
        return f"âœ… Unstaged file: {file_path}"

    except Exception as e:
        return f"âŒ Failed to unstage file: {str(e)}"


@function_tool
async def git_commit(project_name: str, commit_message: str) -> str:
    """Commit only staged changes (like VS Code)."""
    try:
        project_path = os.path.join(PROJECTS_ROOT, project_name)
        repo = Repo(project_path)

        # Check if thereâ€™s anything staged
        if not repo.index.entries:
            return "âš ï¸ No staged changes to commit."

        repo.index.commit(commit_message)
        return f"âœ… Commit successful: '{commit_message}'"

    except Exception as e:
        return f"âŒ Failed to commit: {str(e)}"


@function_tool
async def git_push(project_name: str, branch: str = "main") -> str:
    """Push commits to remote origin."""
    try:
        project_path = os.path.join(PROJECTS_ROOT, project_name)
        repo = Repo(project_path)

        if "origin" not in [r.name for r in repo.remotes]:
            return "âš ï¸ No remote named 'origin'. Add one before pushing."

        origin = repo.remotes.origin
        origin.push(refspec=f"{branch}:{branch}")

        return f"âœ… Successfully pushed '{branch}' to remote."

    except Exception as e:
        return f"âŒ Failed to push: {str(e)}"


@function_tool
async def git_undo_last_commit(project_name: str, keep_changes: bool = True) -> str:
    """
    Undo the last commit.
    If keep_changes=True â†’ soft reset (keeps changes as unstaged).
    If keep_changes=False â†’ hard reset (discards changes).
    """
    try:
        project_path = os.path.join(PROJECTS_ROOT, project_name)
        repo = Repo(project_path)

        if keep_changes:
            repo.git.reset("--soft", "HEAD~1")
            return "â†©ï¸ Last commit undone, changes kept."
        else:
            repo.git.reset("--hard", "HEAD~1")
            return "ğŸ—‘ï¸ Last commit undone and changes discarded."

    except Exception as e:
        return f"âŒ Failed to undo last commit: {str(e)}"


@function_tool
async def git_status(project_name: str) -> str:
    """Get the current git status (staged, unstaged, untracked)."""
    try:
        project_path = os.path.join(PROJECTS_ROOT, project_name)
        repo = Repo(project_path)

        return repo.git.status()

    except Exception as e:
        return f"âŒ Failed to get status: {str(e)}"
    
