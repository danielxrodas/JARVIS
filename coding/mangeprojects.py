from livekit.agents import function_tool
import os
import subprocess
import json
import openai
from dotenv import load_dotenv
import re

load_dotenv()

# File to store the last opened project path
PROJECT_MEMORY_FILE = os.path.expanduser(
    "/Users/daniel/Documents/Projects/VISUAL STUDIO CODE/project_memory.json"
)
def save_current_project(project_path: str):
    """Save the last opened project to memory."""
    with open(PROJECT_MEMORY_FILE, "w") as f:
        json.dump({"current_project": project_path}, f)

def get_current_project() -> str:
    """Retrieve the last opened project from memory."""
    if os.path.exists(PROJECT_MEMORY_FILE):
        with open(PROJECT_MEMORY_FILE, "r") as f:
            data = json.load(f)
            return data.get("current_project")
    return None

# Hardcoded root path for all projects
PROJECTS_ROOT = os.path.expanduser(
    "/Users/daniel/Documents/Projects/VISUAL STUDIO CODE"
)  # Change this if needed

def get_comment_prefix(file_name: str) -> str:
    """Return correct comment prefix based on file extension."""
    extension = os.path.splitext(file_name)[1].lower()
    return {
        ".py": "#",
        ".js": "//",
        ".ts": "//",
        ".java": "//",
        ".c": "//",
        ".cpp": "//",
        ".cs": "//",
        ".go": "//",
        ".rb": "#",
        ".php": "//",
        ".swift": "//"
    }.get(extension, "#")  # Default to Python-style comments
    
@function_tool
async def manage_vscode_project(project_name: str, language: str = "python") -> str:
    """
    Create or open a VS Code project automatically.

    Args:
        project_name (str): Name of the project (e.g., "MyApp").
        language (str): Programming language for the project. Default = "python".

    Returns:
        str: Status message.
    """
    try:
        # Ensure the root folder exists
        os.makedirs(PROJECTS_ROOT, exist_ok=True)

        # Full path for this project
        project_path = os.path.join(PROJECTS_ROOT, project_name)

        # Check if project already exists
        project_exists = os.path.exists(project_path)

        if not project_exists:
            os.makedirs(project_path, exist_ok=True)

            # Create a virtual environment for Python projects
            if language.lower() == "python":
                subprocess.run(
                    ["python3", "-m", "venv", os.path.join(project_path, "venv")]
                )

            # Add a default README.md
            readme_path = os.path.join(project_path, "README.md")
            with open(readme_path, "w") as f:
                f.write(f"# {project_name}\n\nGenerated by Jarvis.\n")
                
            

        # ‚úÖ Save project path so Jarvis knows the active project
        save_current_project(project_path)

        # Open VS Code via AppleScript
        applescript = f'''
        tell application "Visual Studio Code"
            open POSIX file "{project_path}"
            activate
        end tell
        '''
        subprocess.run(["osascript", "-e", applescript])

        if project_exists:
            return f"üìÇ Opened existing project: {project_name}"
        else:
            return f"üÜï Created and opened new {language} project: {project_name}"

    except Exception as e:
        return f"‚ùå Failed to manage project: {str(e)}"


@function_tool
async def create_or_open_file(file_name: str) -> str:
    """
    Create or open a file inside the **currently active VS Code project**.

    Args:
        file_name (str): Name of the file (e.g., "main.py" or "src/app.js").

    Returns:
        str: Status message.
    """
    try:
        # ‚úÖ Get the active project from memory
        project_path = get_current_project()
        if not project_path:
            return "‚ö†Ô∏è No active project found. Please open a project first using manage_vscode_project."

        # Build full path for the file
        file_path = os.path.join(project_path, file_name)

        # Create necessary directories if they don't exist
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        # Create file if it doesn't exist
        open(file_path, "a").close()

        # Open the file inside VS Code in the SAME window
        subprocess.run(["code", "--reuse-window", file_path])

        return f"‚úÖ File '{file_name}' opened at {file_path}"

    except Exception as e:
        return f"‚ùå Failed to open file: {str(e)}"
    

@function_tool
async def generate_code_in_file(file_name: str, prompt: str, model: str = "gpt-4o-mini") -> str:
    """
    Generate code using OpenAI and insert it into a file inside the active project.
    Explanations are automatically converted into code comments.
    """
    try:
        # Get the active project path
        project_path = get_current_project()
        if not project_path:
            return "‚ö†Ô∏è No active project found. Please open a project first using manage_vscode_project."

        # Build full path for the file
        file_path = os.path.join(project_path, file_name)
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        # Initialize OpenAI client
        openai.api_key = os.getenv("OPENAI_API_KEY")
        if not openai.api_key:
            return "‚ö†Ô∏è OpenAI API key not set. Please set OPENAI_API_KEY in your environment variables."

        # Detect comment style based on file extension
        comment_prefix = get_comment_prefix(file_name)

        # Generate code
        response = openai.chat.completions.create(
            model=model,
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You are an expert code generator. "
                        "Always return clean, executable code. "
                        "Any explanations must be provided ONLY as inline comments "
                        f"using '{comment_prefix}' syntax. "
                        "Do not return Markdown formatting, no triple backticks."
                    )
                },
                {"role": "user", "content": prompt}
            ]
        )

        # Get raw response content
        code = response.choices[0].message.content.strip()

        # Remove any leftover triple backticks or markdown formatting
        code = re.sub(r"```[a-zA-Z0-9]*", "", code).replace("```", "").strip()

        # Write clean code with explanations as comments
        with open(file_path, "w") as f:
            f.write(code)

        # Open the file inside VS Code in the same window
        subprocess.run(["code", "--reuse-window", file_path])

        return f"‚úÖ Code generated with explanations as comments in '{file_name}'"

    except Exception as e:
        return f"‚ùå Failed to generate code: {str(e)}"